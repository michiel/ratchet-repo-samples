(function(input, context) {
    const { limit = 5 } = input;
    
    try {
        // Build API URL with parameters
        const baseUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
        let params = [
            `resultsPerPage=${Math.min(limit, 2000)}`,
            `startIndex=0`
        ];
        
        const url = `${baseUrl}?${params.join('&')}`;
        
        // Make API request
        const response = fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': 'Ratchet-CVE-Retriever/1.0'
            }
        });
        
        if (!response.ok) {
            throw new NetworkError(`NVD API returned ${response.status}: ${response.statusText}`);
        }
        
        const data = response.body;
        
        if (!data || !data.vulnerabilities) {
            return {
                cves: [],
                totalResults: 0,
                requestParams: { limit },
                timestamp: new Date().toISOString()
            };
        }
        
        // Transform CVE data to simplified format
        const simplifiedCves = data.vulnerabilities.slice(0, limit).map(vuln => {
            const cve = vuln.cve;
            
            // Extract description
            const description = cve.descriptions?.find(desc => desc.lang === 'en')?.value || 'No description available';
            
            // Extract CVSS data
            let severity = 'UNKNOWN';
            let cvssScore = null;
            let vector = null;
            
            if (cve.metrics?.cvssMetricV31?.length > 0) {
                const cvss = cve.metrics.cvssMetricV31[0];
                severity = cvss.cvssData.baseSeverity || 'UNKNOWN';
                cvssScore = cvss.cvssData.baseScore || null;
                vector = cvss.cvssData.vectorString || null;
            } else if (cve.metrics?.cvssMetricV30?.length > 0) {
                const cvss = cve.metrics.cvssMetricV30[0];
                severity = cvss.cvssData.baseSeverity || 'UNKNOWN';
                cvssScore = cvss.cvssData.baseScore || null;
                vector = cvss.cvssData.vectorString || null;
            } else if (cve.metrics?.cvssMetricV2?.length > 0) {
                const cvss = cve.metrics.cvssMetricV2[0];
                cvssScore = cvss.cvssData.baseScore || null;
                vector = cvss.cvssData.vectorString || null;
                // Map CVSS v2 to severity levels
                if (cvssScore >= 7.0) severity = 'HIGH';
                else if (cvssScore >= 4.0) severity = 'MEDIUM';
                else if (cvssScore > 0) severity = 'LOW';
            }
            
            // Extract CWE information
            const cweIds = cve.weaknesses?.map(weakness => 
                weakness.description?.filter(desc => desc.lang === 'en')
                    .map(desc => desc.value)
            ).flat().filter(Boolean) || [];
            
            // Extract references
            const references = cve.references?.map(ref => ref.url).filter(Boolean) || [];
            
            // Extract affected products from configurations
            const affectedProducts = [];
            if (cve.configurations?.nodes) {
                for (const node of cve.configurations.nodes) {
                    if (node.cpeMatch) {
                        for (const match of node.cpeMatch) {
                            if (match.criteria) {
                                // Parse CPE to extract vendor and product
                                const cpeParts = match.criteria.split(':');
                                if (cpeParts.length >= 5) {
                                    const vendor = cpeParts[3];
                                    const product = cpeParts[4];
                                    if (vendor && product) {
                                        affectedProducts.push(`${vendor}:${product}`);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return {
                id: cve.id,
                published: cve.published,
                lastModified: cve.lastModified,
                description: description,
                severity: severity,
                cvssScore: cvssScore,
                vector: vector,
                cwe: cweIds,
                references: references,
                affectedProducts: [...new Set(affectedProducts)].slice(0, 20) // Deduplicate and limit
            };
        });
        
        return {
            cves: simplifiedCves,
            totalResults: data.totalResults || simplifiedCves.length,
            requestParams: { limit },
            timestamp: new Date().toISOString()
        };
        
    } catch (error) {
        return {
            error: error.message,
            errorName: error.name,
            errorStack: error.stack,
            timestamp: new Date().toISOString()
        };
    }
})